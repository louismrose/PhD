\documentclass[a4paper]{article}

\usepackage{listings}

\begin{document}
%- Use experience on existing projects to derive requirements
%- Use example data to analyse existing co-evolution tools
%- Use drawbacks of existing tools to derive requirements
%- Use interviews to derive requirements

\abstract{I have defined requirements for managing co-evolution in the context of MDE. My requirements definition process involved first defining high-level requirements by reviewing co-evolution literature and from my experiences with metamodelling. Then, I devised six experiments to further investigate these high-level requirements. Each experiment was run using two co-evolution tools. The merits and drawbacks of each tool were noted, and used to derive requirements. I will identify further requirements by interviewing modelling experts at ETAPS.}


\section{Metamodelling Experience}

Existing literature focuses on automating the migration of large numbers of models. When collaborating with Conmy on FPTC, we made changes to a metamodel that caused it to become inconsistent with all of its models. We had a large number of inconsistent models that needed to be migrated. Migrating each model by hand would have been time-consuming and error-prone.

\emph{\textbf{R1}: Structures and processes for managing inconsistency must enable the automated migration of (a large number of) inconsistent models.}

Instead of manual migration, I constructed a model-to-model transformation to perform automated migration. I discovered some drawbacks to this approach. Firstly, I had to manually determine the cause of inconsistencies, and then formulate and codify the entire transformation, which was time consuming. Secondly, the language lacked facilities for encoding this kind of transformation: for example, explicit copying of data occurred often and was tedious to write.

To aid the formulation of migration strategies:

\emph{\textbf{R2}: Structures and processes for managing inconsistency must identify and report inconsistencies.}

\emph{\textbf{R3}: Structures and processes for managing inconsistency must provide assistance in formulating migration strategies.}

\emph{\textbf{R4}: The language used for specifying migration strategies must provide task-specific features (e.g. constructs for distinguishing between existing and newly created model elements).}

Not all of the inconsistent models were mine - Conmy and Xiaocheng Ge also had inconsistent models. Migration was not performed by one person for all models; each model owner needed the ability to migrate their own models. Gruschko also notes the need for this kind of separation.

\emph{\textbf{R5}: Structures and processes for managing inconsistency must allow the separation of specifying migration strategies and executing migration strategies.}

I have collaborated with Barber and Sampson in producing metamodels of their domains. Metamodel development was iterative and incremental. Each iteration comprised two stages: changing the metamodel and validating the change. The latter involved instantiating the metamodel, producing one or two models, to ensure that the metamodel was representative of the domain. Changing the metamodel often caused the models used in the previous iteration to become inconsistent. We needed a way to manage this inconsistency, despite having only a small number of models.

\emph{\textbf{R6}: Structures and processes for managing inconsistency must enable the automated migration of inconsistent models, even when the number of models is small.}


\section{Experimentation}

To further investigate the above requirements, I experimented with two existing tools for managing co-evolution and performing automated model migration, COPE and Cicchetti's (unnamed) tool. I devised six experiments; each related to the high-level requirements defined in the previous section. I used the data identified in my progress report during the experiments. (Namely, the FPTC metamodel, the xText metamodel, metamodels derived from OO refactorings, and the metamodels from collaborations with Sampson and Barber).

\subsection{E1, E2: Producing migration strategies}

Experiments 1 and 2 (E1 and E2) focused on detecting, generating and codifying migration strategies. E1 and E2 related to high-level requirements R1, R2, R3 and R4. Herrmannsd\"{o}rfer et al. identify two types of migration strategy: metamodel-independent and metamodel-specific. The former is reusable and can be applied to instances of any metamodel, while the latter is specific to a single metamodel. E1 focused on the metamodel-independent migration strategies, while E2 focused on metamodel-specific migration strategies.

\subsubsection{Identifying and reporting inconsistencies}

\emph{\textbf{R1}: Structures and processes for managing inconsistency must enable the automated migration of (a large number of) inconsistent models.}

\emph{\textbf{R2}: Structures and processes for managing inconsistency must identify and report inconsistencies.}

Cicchetti's tool does not identify or report inconsistencies.

COPE enforces consistency after migration - COPE rolls back the execution of a migration strategy if the resulting model is inconsistent with its metamodel. This seems to be an unnecessary restriction; in some cases a migration strategy might be used only to reduce inconsistency.

\emph{\textbf{R1.1}: The automated migration of inconsistent models need not leave all models in a consistent state.}

COPE reports an error if a migration strategy leaves a model inconsistent. However, the error messages are unclear because they are written in terms of the metamodelling language, rather than in terms of the domain being modelled.

\emph{\textbf{R2.1}: Inconsistencies must be reported in a clear and understandable way, using concepts from the metamodel and model where possible.}


\subsubsection{Assistance in formulating migration strategies}

\emph{\textbf{R3}: Structures and processes for managing inconsistency must provide assistance in formulating migration strategies.}

Both tools provided facilities for reducing the effort required to formulate migration strategies.

Both COPE and Cicchetti provide several metamodel-independent migration strategies. When a metamodel change had a corresponding metamodel-independent migration strategy, I found that using the metamodel-independent migration strategies greatly reduced the effort needed to migrate models.

\emph{\textbf{R3.1}: Structures and processes for managing inconsistency must support the specification and execution of metamodel-independent migration strategies.}

\emph{\textbf{R3.1.1}: Structures and processes for managing inconsistency must provide definitions for frequently occurring metamodel-independent migration strategies.}

It was often difficult to ascertain the effects of COPE and Cicchetti's metamodel-independent migration strategies. Often, I had to guess the effects, and frequently, they were not what I expected.

\emph{\textbf{R3.1.2}: Structures and processes for managing inconsistency must provide clear descriptions of the effects of metamodel-independent migration strategies.}

Both tools did not include migration strategies for some of the metamodel-independent changes that were present in my example data. I was able to add migration strategies to both tools by extension. 

\emph{\textbf{R3.1.3}: Structures and processes for managing inconsistency must allow extension via new metamodel-independent migration strategies.}

COPE provides an Eclipse extension point for contributing new metamodel-independent co-evolution operators. Creating a plug-in is a non-trivial activity. 

\emph{\textbf{R3.1.3.1}: Mechanisms for extension must be as simple as possible.}


Turning now to metamodel-specific migration strategies, I found that COPE and Cicchetti's tools offer very little assistance in formulating metamodel-specific migration strategies. The former generates code for performing the metamodel adaption and makes available any variables used to the migration strategy. The latter could highlight the model elements that require migration by using an instance of the model difference metamodel, but does not do so.

\emph{\textbf{R3.2}: Structures and processes for managing inconsistency must provide assistance in formulating metamodel-specific migration strategies.}


Generalising metamodel-specific is one approach to formulating metamodel-independent changes. COPE does not provide any tool support for this kind of  generalisation. In COPE, metamodel-independent changes are encoded in a very similar way to metamodel-specific changes, so in some cases code can be copy and pasted. Some variables must then be introduced in place of references to elements of the specific metamodel. I found writing a metamodel-independent migration strategy in Cicchetti's tool to be very difficult without having first written a related metamodel-specific migration strategy. Doing the latter highlights the M2M concepts that need to be generated when doing the former. However, no processes or structures for assisting with this generalisation are present in Cicchetti's tool.

\emph{\textbf{R3.2}: Structures and processes for managing inconsistency must provide assistance in deriving metamodel-independent migration strategies from metamodel-specific migration strategies.}


\subsubsection{Task-specific features}

\emph{\textbf{R4}: Languages for specifying migration strategies must provide task-specific features (e.g. homogeneous transformation, constructs for distinguishing between existing and newly created model elements).}

I investigated COPE and Cicchetti's tool to determine whether their approaches to specifying migration strategies offered any advantages over using a model-to-model transformation (M2M) language.

When using a M2M language to specify migration strategies, I had to write code for migrating model elements that did not change between original and migrated model. Both COPE and Cicchetti's tool assume that migration strategies only specify changes for model elements that change during migration. Consequently, I found specifying migration strategies using COPE or Cichchetti's tool (rather than a M2M language) to yield more concise and more readable results.

\emph{\textbf{R4.1}: Languages for specifying migration strategies must not require specifications to include explicit copying of unchanging model elements from original to migrated model).}

COPE and Cicchetti use different approaches to ensure that migration strategies need not include explicit copying of data:

\paragraph{COPE - Homogenous transformation} COPE migration strategies are executed using a homogenous transformation engine. Homogenous transformations can only be used when transforming between models that have the same metamodel. But during co-evolution, we wish to migrate from one version of a metamodel to another; the original and adapted metamodels are different. As I identified in my presentation at MoDELS 08, the solution is to use a metamodel-independent syntax (e.g. HUTN) to represent the models that we wish to migrate. First, we (heterogeneously) transform from an instance of the original metamodel to an instance of the metamodel-independent syntax. Next, we (homogeneously) transform from an inconsistent to a consistent model in the metamodel-independent syntax. Finally, we (heterogeneously) transform from an instance of the metamodel-independent syntax to an instance of the adapted metamodel. The heterogeneous transformations to and from the metamodel-independent syntax can be specified in a metamodel-independent manner. Consequently, only the homogenous transformation needs to be specified when defining a migration strategy. COPE uses exactly this approach.

\paragraph{Cicchetti - Higher-order transformation}
Cicchetti's tool compares original and adapted metamodels to produce a difference model (an instance of Cicchetti's difference metamodel). Subsequently, a higher-order transformation (that takes the difference model and original metamodel as input) is executed to generate a model-to-model transformation that can be used to copy unchanging model elements from original to migrated model.


I also considered the readability and conciseness of the migration strategies that I wrote in both COPE and Cicchetti's tool. I found that some patterns reoccurred in several COPE migration strategies. I re-used them by creating Groovy operations and using the Groovy import mechanism, reducing duplication. COPE doesn’t support functions as arguments to (or subtyping of) migration strategies. The Split Class change from the PO metamodel could be generalised and re-used if it did.

\emph{\textbf{R4.3}: Languages for specifying migration strategies must provide constructs that enable re-use.}


In both tools, the syntax used for specifying migration strategies is representative of the underlying implementation. COPE requires migration strategies to be specified in terms of instances and slots, concepts from the metamodel-independent syntax used for homogenous transformation. Cicchetti's tool requires metamodel-independent migration strategies to produce rules and rule bodies, concepts from the syntax of ATL, which is used to execute migration strategies. To be able to specify migration strategies correctly in either tool, I had to understand its implementation.

\emph{\textbf{R4.4}: Languages for specifying migration strategies must not presume or require understanding of the underlying language implementation .}


% get(), set(), unset() in COPE migration strategies are used to manipulate slots (which are used to store values in objects; each object comprises zero or more slots, and each slot is associated with exactly one attribute in the metamodel). Using methods to represent get, set and unset detracts from readability. Worse still, the arguments to these methods are fully qualified metamodel elements. Migration strategies could be more concise if get, set and unset were implemented as primitive (infix) operators and used arguments relative to the current object (e.g. compare Listing \ref{lst:cope} with Listing \ref{lst:cope-alt}).
% 
% \begin{lstlisting}[caption=Get and unset in COPE migration strategies., label=lst:cope]
% block.get(fptc.Block.connections)
%   .addAll(anotherBlock.unset(fptc.Block.connections))
% \end{lstlisting}
% 
% \begin{lstlisting}[caption=Alternative to COPE get and unset., label=lst:cope-alt]
% // Note the use of ! to denote unsetting a value
% block.connections.addAll(anotherBlock!connections)
% \end{lstlisting}
% 
% On two occasions when using COPE, I had to implement a clone method for (metamodel-independent) objects.


% I feel that migration strategies could have more structure than they do in COPE. Consider the following migration strategy for Extract Subclass:
% 
% // model migration
%   for(contextInstance in contextClass.allInstances) {
%     for(feature in features) {
%       if (contextInstance.isSet(feature)) {
%         // migrate to subclass
%         contextInstance.migrate(subclass)
%         break;
%       }
%     }
%   }
% In this case, only a subset of all instances (of contextClass) need to be migrated. A guard for the migration might be useful:
% 
% 
%   migrate each instance i of contextClass
%     when
%       features.exists(feature | i.isSet(feature))
%     do
%       contextInstance.migrate(subclass)
%     when
%       ...
%     do
%       ...
%    end


% It wasn’t possible to implement a metamodel-independent migration strategy for Change Containment to Reference, as COPE does not support metamodel-independent migration strategies that require model elements as arguments. Only metamodel elements may be passed as arguments to metamodel-independent migration strategies.

% COPE provides excellent support for customising migration strategies. Migration strategies are written in Groovy/Java, and consequently the full power of those languages are available when specifying migration strategies.
% 
% Groovy’s closures provided expressive and concise alternatives for iterating over loops, and for performing existential and universal queries on collections.


Debugging metamodel-independent migration strategies was time-consuming in both tools. In Cicchetti's tool, error messages were reported only directly from the underlying implementation (ATL) (which relates to requirement R4.4). In COPE, errors were poorly explained (e.g. ‘The validContainment constraint has been violated for ‘an instance of Port’,’ which meant that a port was contained in more than one parent objects, when it should have been contained in exactly one).

\emph{\textbf{R4.5}: Structures and processes for managing inconsistency must report error messages that are clear and include appropriate traceability information (e.g. specifying the model element that caused the error to occur).}


Herrmannsd\"{o}rfer et al. identify model-specific migration strategies as a subset of metamodel-specific migration strategies - instances of the same metamodel sometimes require different migration strategies. My example data showed that in one case (Process-Oriented: Split ConnectionPoint), some model elements in the same model required different migration strategies and that only a human who understands the model can determine which migration strategy should be used.

\emph{\textbf{R4.6}: Structures and processes for managing inconsistency must allow interactivity with the user doing the migration when executing a migration strategy.}


Neither COPE nor Cicchetti's tool provide mechanisms for indicated that a migration strategy cannot be applied, yet my example data showed that in several cases (FPTC: FaultSets, Process-Oriented: Split ConnectionPoint, OO Refactoring: MoveFeature) fully automated migration cannot be performed for some models. 

\emph{\textbf{R4.6}: Structures and processes for managing inconsistency must provide means for indicating when a migration strategy cannot be applied to migrate an inconsistent model (e.g. using pre-conditions, allowing authors of migration strategies to throw errors).}



\subsection{E3: Economies of Scale}

Experiment 3 (E3) focused on migrating large and small numbers of inconsistent models. E3 related to high-level requirements R1 and R6.


\subsubsection{Migrating Few Inconsistent Models}

\emph{\textbf{R6}: Structures and processes for managing inconsistency must enable the automated migration of inconsistent models, even when the number of models is small.}

The benefits of automated migration do not necessarily hold when the number of inconsistent model elements is small - manual migration may be quicker. Migrating a single model with COPE requires a migration strategy be encoded in Groovy. When migrating a model in response to an occurrence of one of the built-in metamodel-independent changes, COPE can be used to generate this migration strategy (assuming that the user has used the COPE metamodel editor).

In the following situations, some extra effort is required:

\begin{itemize}
  \item A different metamodel editor has been used: the metamodel adaptation must be recreated in the COPE editor.
  \item The metamodel adaptation cannot be recreated using only COPE’s built-in metamodel independent changes: a migration strategy must be written in Groovy.
\end{itemize}

When COPE could automatically generate a migration strategy, I found the effort required to perform automated migration was similar to that required to perform manual migration for a small number of inconsistent model elements. In the two situations listed above, I found the effort required to perform automated migration was much greater than that required to perform manual migration for a small number of inconsistent model elements.

When using Cicchetti's tool, migrating a single model always requires the definition of at least one ATL model-to-model transformation. I found the effort required to perform automated migration to be greater than that that required to perform manual migration for a small number of inconsistent model elements.

These are informal observations. Further evaluation of these tools is required to produce accurate measurements of effort.

\emph{\textbf{R6.1}: Co-evolution must be supported by structures and process that reduce the effort required to perform migration of inconsistent models. The effort required when using these structures and processes should be less than the effort required to perform migration when not using them.}


\subsubsection{Migrating Many Inconsistent Models}

\emph{\textbf{R1}: Structures and processes for managing inconsistency must enable the automated migration of (a large number of) inconsistent models.}

The benefits of automated migration are increased when applied to larger numbers of inconsistent model elements. Consequently, it seems reasonable to expect tools that support automated co-evolution to allow the automated migration of more than one model at a time (i.e. a batch mode). COPE does not provide a batch mode for migrating models; models must be migrated one at a time. Cicchetti's tool does provide support for migrating many models at once, but a little development effort would be required to produce a front-end.


\subsection{E4, E5: Distributed Work}
Experiments 4 and 5 (E4 and E5) focused on working in a distributed environment. In particular, they concentrated on sharing migration strategies and deferring migration to a later date (E4), and merging metamodel changes (E5). E4 and E5 relate to high-level requirement R5.

\emph{\textbf{R5}: Structures and processes for managing inconsistency must allow the separation of specifying migration strategies and executing migration strategies.}

\subsubsection{Sharing Migration Strategies}
Cicchetti's tool allowed migration strategies to be distributed to other machines. However, the underlying transformation engine, ATL, needed to be installed on recipient machines. It would be better if migration strategies could be distributed without the need for recipients to install anything more than the modelling tool (Eclipse/EMF in this case).

\emph{\textbf{R5.1}: When used to distribute migration strategies, structures and processes for managing inconsistency must presume only that the modelling tool (e.g. Eclipse/EMF) is available for executing migration.}

Cicchetti's migration strategies were small enough to distribute between personal computers (Less than 50KB, often less then 20KB).

\emph{\textbf{R5.2}: When used to distribute migration strategies, structures and processes for managing inconsistency must produce files small enough to share between personal computers.}


\subsubsection{Merging Metamodel Changes}
\label{sssec:merging}
While E4 used email to distribute migration strategies, E5 concentrated on investigating integration with source code management systems, such as CVS.

Neither COPE nor Cicchetti's tool makes assumptions about what type of SCM is used. I appreciated this decoupling as I used two different source code management systems (CVS, SVN). 

\emph{\textbf{R1.4}: Structures and processes for managing inconsistency must be decoupled from storage and versioning of development artefacts.}

Using a source code management system to merge metamodels was somewhat complicated by COPE. I had to merge the metamodel changes, and then I needed to merge the history model changes. COPE provides no support for merging history model changes and history models cannot be edited by hand. Consequently, I had to resort to editing the underlying XML to merge history model changes. Once a COPE history model has been merged. It can be used to generate a new migrator (i.e. for the most part, migration strategies need not be merged by hand).

When using Cicchetti's tool, merging metamodels requires the merging of any generated metamodel-specific migration strategies. Difficulty can arise when both transformations change intersecting subsets of model elements.

\emph{\textbf{R1.5}: Structures and processes for managing inconsistency must not complicate versioning of development artefacts.}


\subsection{E6: Impact on Development Work}
Experiment 6 consisted of reflecting on previous experiments and commenting on how the tools altered my development process (other than the impact on version control, which was discussed in Section \ref{sssec:merging}).

Ideally, structures and processes for managing inconsistency should not restrict the developer's choice of tools (e.g. metamodel editor, model editor). However, perhaps such restrictions are acceptable if they are required to provide other benefits.

COPE restricts the choice of metamodel editor; COPE’s bespoke metamodel editor must be used to make metamodel changes. COPE needs to be able to deduce a sequence of primitive metamodel changes. Consequently, a textual editor (e.g. Emfatic) - allowing free-form editing of the metamodel - cannot be used to make metamodel changes.

\end{document}