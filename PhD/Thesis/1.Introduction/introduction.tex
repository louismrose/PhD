%!TEX root = /Users/louis/Documents/PhD/Deliverables/Thesis/thesis.tex

% TODO - I probably need to introduce model-metamodel co-evolution here, to make the method and structure sections more understandable. It might be possible to include an example of evolution in MDE in this chapter, and to identify types of evolution including model-metamodel co-evolution.

\chapter{Introduction}
\label{Introduction}
Today's software developers build distributed and interoperating systems with sophisticated graphical interfaces rather than the insular, monolithic, and command-line driven mainframe applications built by their predecessors. The National Programme for IT\footnote{\url{http://www.connectingforhealth.nhs.uk/about/benefits/statement0607.pdf}} seeks to modernise the United Kingdom's National Health Service (NHS) by replacing paper for computerised systems in managing the nation's patient records. 

Some of the software demanded by users and developers today is so complicated that its construction is not possible, even using state-of-the-art software engineering techniques \cite{selic03pragmatics}. However, demand does not appear to exceed capability in all areas of computer science.

%\cite{pool97society} observes that a similar situation occurred when steam and electrical power were introduced during the Industrial Revolution. 

Hardware development, for example, seems to advance more quickly than software development. Each year, faster personal computers with larger disk drives become available, while operating systems, office software and development environments seem to improve more gradually. \cite{brooks86nosilverbullet} suggests that radical advances in software development occur only by raising the level of abstraction at which software is specified.

%  

% \cite{brooks86nosilverbullet} observes that engineering increasingly complicated systems with traditional development approaches presents many challenges, including:
% 
% \begin{enumerate}
%  \item \textit{Increasing size of development teams}: large teams may experience communication difficulties, detracting from productivity.
%  \item \textit{Difficulties providing system overviews}: incomplete system knowledge can impede maintenance activities.
%  \item \textit{Poor understandability}: new developers suffer a complex learning curve.
%  \item \textit{Resistance to change}: development reacts slowly when requirements change, new underlying technologies are to be adopted, and unintended behaviour must be corrected.
% \end{enumerate}
% 
% 
% 
% Improvements to development processes have also facilitated greater abstraction. For example, developers are increasingly employing models of systems to aid design and implementation. During the 1990s, methods that prescribed modelling to aid software development were popular. A common modelling language, the Unified Modelling Language (UML) \cite{uml212}, was standardised by combining the modelling languages from three methods \cite{}. By communicating designs and abstracting away from unimportant details, software engineers are using models to address the first three of Brooks's challenges. However, modelling is effective only when the models are an accurate representation of the computer system.

% During a system's lifecycle, design documents are often neglected and become out-of-date. Without a well-defined connection to the system's implementation, models are effectively design documents that might be neglected and can become inaccurate representations of the system \cite{frankel02mda,kleppe03mda}. For models to be used as effective means of communication and education, they must be accurate and, therefore, must be maintained and updated in response to change. Maintaining two unconnected representations of a system (models and implementation) obviously detracts from the productivity of the development team. Instead, an approach to software development that integrates modelling and coding can be used to address this productivity problem, as well as the first three of Brooks's challenges.


\input{1.Introduction/topics}
\input{1.Introduction/problems}
\input{1.Introduction/hypothesis}
\input{1.Introduction/method}
\input{1.Introduction/results}
\input{1.Introduction/structure}

