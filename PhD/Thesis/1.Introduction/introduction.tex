%!TEX root = /Users/louis/Documents/PhD/Deliverables/Thesis/thesis.tex

\chapter{Introduction}
\label{Introduction}

\section{Model-Driven Engineering}
%The proposed thesis will begin by discussing the challenges that MDE addresses. Terminology relevant to MDE will be introduced (including terms such as \emph{model}, \emph{metamodel} and \emph{model transformation}). The benefits of MDE will be discussed along with the main threats to its adoption, which include challenges for controlling and managing software evolution with MDE \cite{mens07softwareevolution}.

There is demand for increasingly complicated software, the construction of which is currently beyond our ability. \cite{selic03pragmatics} observes that a similar situation occurred when steam and electrical power were introduced during the Industrial Revolution \cite{pool97society}. 

\section{Software Evolution}
%The introduction will then discuss software evolution, and its causes. The challenges presented by software evolution will be highlighted, particularly in the context of MDE, and used to motivate the proposed thesis.

Studies \cite{erlikh00leveraging,moad90maintaining} suggest that the evolution of software can account for as much as 90\% of a development budget. Such figures are sometimes described as uncertain \cite[ch. 21]{sommerville06software}, mainly because terms such as evolution and maintenance are used ambiguously. However, precise figures are not required to see that the effects of evolution can inhibit the productivity of software development. For example, Section \ref{Intro:MigrationProblem} illustrates an example of the issues caused by evolution, in the context of model-driven engineering.

Studying software evolution can provide benefits other than improving the maintainability of a system. For instance, by understanding the mistakes made in the engineering of existing software systems, similar mistakes may be avoided in the future. Experts and analysts can devise best practices that guide developers away from problematic practices. For this reason, Kerievsky notes that ``studying the evolution of great software designs will be more valuable than studying the great designs themselves'' \cite{kerievsky04refactoring}.

\cite{lehman80understanding,lehman78programs,lehman69programming} identify several laws of software evolution for \textit{evolutionary-type systems} (\textit{E-type systems}) -- systems that solve problems or implement software in the real world. E-type systems differ from \textit{specification-type systems} (\textit{S-type systems}) where the ``sole criterion of acceptability is correctness in the mathematical sense'' \cite{lehman85program}.

The law of \textit{continuing change} states that ``E-type systems must be continually adapted else they become progressively less satisfactory'' \cite{lehman78programs}. Later, Lehman et al. \cite{lehman96laws} introduce another complementary law, the law of \textit{declining quality}: ``The quality of E-type systems will appear to be declining unless they are rigorously maintained and adapted to operational environment change''. Both laws indicate that the evolution of E-type systems during their effective lifetime is inevitable.


\section{Research Aim}
%The high-level aim of the research will be stated, providing a context for the background and literature review chapters. 

\section{Research Method}
\label{sec:research_method}
%This section will discuss the way in which the research was conducted, including a description of the evaluation strategy.

Due to the method employed, Dig's refactoring research is the most relevant to this research. Initially, \cite{dig06apis} conducted a survey to identify and categorise the changes made to five mid-sized APIs, with the hypothesis that a significant number of the changes could be classified as behaviour-preserving (i.e. refactorings). By using examples from the survey, \cite{dig06detection} were able to devise an algorithm for automatically detecting refactorings to a high degree of accuracy (over 85\%). The algorithm was then utilised in tools for (1) replaying refactorings to perform migration of client code following breaking changes to an API \cite{dig06automatic}, and (2) versioning object-oriented programs using a refactoring-aware configuration management system \cite{dig07cms}. The latter facilitated better understanding of program evolution, and the refinement of the refactoring detection algorithm.