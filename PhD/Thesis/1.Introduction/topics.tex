%!TEX root = /Users/louis/Documents/PhD/Deliverables/Thesis/thesis.tex

\section{An Overview of Model-Driven Engineering}
Historically, raising the level of abstraction of software development has led to increased productivity \cite{brooks86nosilverbullet,boehm06view,kelly08dsm}. For example, assembly language provides mnemonics for machine code, allowing developers to disregard extraneous detail (such as the binary representation of instructions). Object-orientation and functional programming permit further abstraction over assembly language, enabling developers to express solutions in a manner that is more representative of their problem domain.

Model-Driven Engineering (MDE) is a contemporary approach to software engineering that seeks to abstract away from technological details (such as programming languages and off-the-shelf software components) and towards the problem domain of the system (for example: accounting, managing patient records, or searching the Internet) \cite{frankel02mda,kleppe03mda,selic03pragmatics}. To this end, MDE prescribes, throughout the software engineering process, the use of models to capture the relevant details of the problem domain. Software development is driven by manipulating (transforming, validating, merging, comparing, etc.) the models to automatically generate an ultimate artefact, such as working code or simulation models.

MDE reportedly provides many benefits over traditional approaches to software engineering. Conclusions \cc drawn from two unpublished case studies suggest that MDE can lead to increased productivity by reducing the amount of time to develop a system, and by reducing the number of defects discovered throughout development \cite{watson08mdahistory}. MDE \cc can be used to increase the productivity of software development and the maintainability of software systems \cite{kleppe03mda}. Separating \cc platform-specific and platform-independent details using MDE can facilitate greater portability of systems \cite{frankel02mda}. Section~\ref{subsec:mde_benefits} discusses further benefits of MDE. 

Notwithstanding its benefits, MDE introduces additional challenges for software development. Large \cc models are commonplace in many software engineering projects, and contemporary MDE environments have not be optimised to facilitate the manipulation of large models \cite{kolovos08scalability}. More \cc generally, MDE introduces new challenges for managing change throughout the lifetime of a system \cite{Mens07}. This thesis focuses on the latter challenge, which is part of a branch of computer science termed \emph{software evolution}.

\section{An Overview of Software Evolution}
\label{sec:intro_to_software_evo}
Software changes over time. During the lifetime of a software system, unintended behaviour must be corrected and new requirements satisfied. Because modern software systems are rarely isolated from other systems, changes are also made to facilitate interoperability with new systems \cite{sjoberg93quantifying}. 

% \cite{lehman80understanding,lehman78programs,lehman69programming} identify several laws of software evolution for \textit{evolutionary-type systems} (\textit{E-type systems}) -- systems that solve problems or implement software in the real world. E-type systems differ from \textit{specification-type systems} (\textit{S-type systems}) where the ``sole criterion of acceptability is correctness in the mathematical sense'' \cite{lehman85program}.
% 
% The law of \textit{continuing change} states that ``E-type systems must be continually adapted else they become progressively less satisfactory'' \cite{lehman78programs}. Later, Lehman et al. \cite{lehman96laws} introduce another complementary law, the law of \textit{declining quality}: ``The quality of E-type systems will appear to be declining unless they are rigorously maintained and adapted to operational environment change''. Both laws indicate that the evolution of E-type systems during their effective lifetime is inevitable.

\emph{Software evolution} is an area of computer science that focuses on the way in which a software system changes over time in response to external pressures (such as changing requirements, or the discovery of unintended behaviour). The terms software evolution and software maintenance are used interchangeably in the software engineering literature. In this thesis, \emph{evolution} is preferred to \emph{maintenance}, because the latter can imply deterioration caused by repeated use, and most software systems do not deteriorate in this manner \cite{ramil00cost}. Other than sharing some terminology, software evolution is not related to evolutionary algorithms, a branch of computer science that encompasses genetic programming and genetic algorithms. 

In the past, studies have suggested that software evolution can account for as much as 90\% of a development budget \cite{erlikh00leveraging,moad90maintaining}, and there is no reason to believe that the situation is different today. Although \cc such figures have been described as uncertain \cite[ch. 21]{sommerville06software}, precise figures are not required to demonstrate that the effects of evolution can inhibit the productivity of software development.

For example, suppose that we are developing a software system using a combination of hand-written code and off-the-shelf components. Part way through development, one of the components changes to support a new requirement. When using the new version of the component, we must first determine whether our system exhibits any unintended behaviour, identify the cause of the unintended behaviour, and change the system accordingly. The resources allocated to correcting any unintended behaviour are not being used to develop features for the users of our system.

Primarily, software evolution research seeks to reduce the cost of making changes to a system. Analysis of the effects of evolution facilitates decision making. For example, analysis of our system might indicate that using a new version of a component will introduce three defects, but simplify the implementation of two features. Studying the way in which systems evolve leads to improvements in software development tools and processes that reduce the effects of evolution. For example, contemporary software development environments recognise compilation as a common activity during software evolution, and often perform automatic and incremental compilation of source code in the background. Future changes to a system might be anticipated by identifying the ways in which the system has previously evolved. For example, understanding the ways in which a system has been affected by using a new version of a component might highlight ways in which the system can be better protected against changes to its dependencies.