%!TEX root = /Users/louis/Documents/PhD/Deliverables/Thesis/thesis.tex

\section{Metamodel-Independent Syntax}
\label{sec:mmi_syntax}
Section~\ref{subsec:modelling_framework_characteristics} discussed the way in which modelling frameworks implicitly enforce conformance, and hence prevent the loading of non-conformant models. Additionally, modelling frameworks provide little support for checking the conformance of a model with other versions of a metamodel, which is potentially useful during metamodel installation. In Section~\ref{sec:requirements_identification}, these concerns lead to the identification of the following requirement: \emph{This thesis must investigate the extension of existing modelling frameworks to support the loading of non-conformant models and conformance checking of models against other metamodels.}

This section describes the way in which existing modelling frameworks load and store models using a metamodel-specific syntax, proposes an alternative syntax and demonstrates how this facilitates automatic consistency checking. The work presented in this section has been published in \cite{rose09enhanced}.

% TODO - intro example
% TODO - present MM independent syntax. Make clear that it is an ABSTRACT syntax.

\subsection{Example} % TODO - need a better name
The example of metamodel evolution in Figure~\ref{fig:x} is used throughout this section. In Figure~\ref{fig:xa}, \texttt{na\-tu\-r\-alCh\-il\-dr\-en} and \texttt{ad\-op\-t\-edCh\-il\-dr\-en} are modelled as separate features, and, in Figure~\ref{fig:xb}, they are modelled as a single feature, \texttt{ch\-il\-dr\-en}.



The model in Figure~\ref{fig:z}, which conforms to Figure~\ref{fig:x}, is used in the remainder of this section. After the metamodel evolves to Figure~\ref{fig:xb}, the model in Figure~\ref{fig:z} no longer conforms to its metamodel. The sequel describes why loading a non-conformant model fails.

% Use EMF's tree editor to display fig:z


\subsection{Binding to a specific metamodel}
\label{subsec:binding_specific}
When represented with XMI, a model refers to its metamodel's types by name, because models and metamodels are kept separate (Section~\ref{subsec:modelling_framework_characteristics}). At the start of an XMI document, one or more metamodels are imported using XML namespaces. In the body of an XMI document, the namespaces are used to refer to metamodel types. For example, Listing~\ref{lst:xmi} is the XMI representation of the model show in Figure~\ref{fig:z}. Line 2 imports metamodels under the \texttt{xmi} and \texttt{fa\-mi\-li\-es} namespaces. In the rest of Listing~\ref{lst:xmi}, the \texttt{xmi} namespace can be used to reference types provided by the modelling framework, and the \texttt{fa\-mi\-li\-es} namespace to reference types provided by the metamodel in Figure~\ref{fig:x}. Line 2, for example, uses the \texttt{fa\-mi\-li\-es} namespace to reference the \texttt{Fa\-mi\-ly} type from the metamodel in Figure~\ref{fig:x}. 

\begin{lstlisting}[caption=Family model in XMI, label=lst:xmi, language=XML]
<?xml version="1.0" encoding="ASCII"?>
<families:Family xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:families="http://www.cs.york.ac.uk/families" xmi:id="_kE2LkAagEeC-FIOYrvUj0A" name="Smiths">
  <naturalChildren xmi:id="_q8RWYAagEeC-FIOYrvUj0A" name="Paul"/>
  <adoptedChildren xmi:id="_nj6TcAagEeC-FIOYrvUj0A" name="John"/>
</families:Family>
\end{lstlisting}

Loading a model involves constructing objects in the underlying programming language. When a model is loaded, modelling frameworks bind the model to its metamodel using the underlying programming language (Section~\ref{subsec:modelling_framework_characteristics}). The metamodel defines the way in which model elements will be bound, and binding is often strongly-typed: each metamodel type is mapped to a corresponding type in the underlying programming language. Binding a model element involves instantiating, in the underlying programming language, the metamodel type, and populating the attributes of the instantiated object with values that correspond to those specified in the model. Figure~\ref{fig:a} shows the (Java) objects that would be created by EMF when loading the XMI in Listing~\ref{lst:xmi}.

Binding fails for non-conformant models. For example, attempting to bind the model shown in Figure~\ref{fig:y} to the metamodel shown in Figure~\ref{fig:xb} fails because the \texttt{Fa\-mi\-ly} class no longer defines features called  \texttt{na\-tu\-r\-alCh\-il\-dr\-en} and \texttt{ad\-op\-t\-edCh\-il\-dr\-en}. Change to a metamodel that affect the conformance of models prevent models non-conformant from being loaded and, hence, used with model editors and model management operations, such as model transformations.



\subsection{Potential solutions for loading non-conformant models}
A metamodel-specific binding requires that a model conforms to its metamodel and, therefore, metamodel evolution can cause metamodel-specific binding to fail. To address this, two potential approaches to binding (and hence loading) non-conformant models have been considered and are now discussed. The benefits and drawbacks of each approach have been compared, which resulted in the selection of the second approach, binding to a generic metamodel.

\subsubsection{Preserving metamodel history}
Presently, modelling frameworks store only the latest version of a metamodel, and hence binding fails for models that conform to a previous version of the metamodel. Storing the entire history of every metamodel would avoid any conformance problems that might be introduced by metamodel evolution. Binding would involve locating the correct version of the metamodel from the history, and proceed in the same manner as a metamodel-specific binding.  

\subsubsection{Binding to a generic metamodel}
Conformance indicates whether a metamodel and model are consistent in terms of their definition and use of types. A metamodel-specific binding fails for a non-conformant model because the types defined in the metamodel cannot be used to construct a representation of the model in the underlying programming language. An alternative, therefore, is to bind models to a metamodel-independent representation in the underlying programming language. Binding is then not dependent on the types defined in metamodels, and will succeed for non-conformant models.
   
\subsubsection{Benefits and drawbacks of the potential solutions}
History
+ Load any version of a model with model editors
+ If mod man operation history is stored too, can use models with mod man operations too

+/- Size of metamodel will be larger. Might need to investigate an efficient storage representation, patches for example.

- Relies on MM dev.
- There's no standard way of storing metamodel histories.


MMI
+ Can load any model, even if we don't have the metamodel / know what it looks like.
+ Doesn't rely on MM user.

- MM is not represented in domain-specific concepts, and hence cannot be used with editors, transformations, etc.


\subsection{Proposed solution: binding to a generic metamodel}
\label{subsec:binding}
For situations when a model does not conform to its metamodel, this thesis proposes an alternative to the binding mechanism described in Section~\ref{subsec:binding_specific}, which binds a model to a \emph{generic} metamodel. A generic metamodel reflects the characteristics of the metamodelling language and consequently every model conforms to the generic metamodel. Figure~\ref{fig:slot_model} shows a minimal generic metamodel for MOF, which is based on the MOF metamodel \cite{mof}. Model elements are bound to \texttt{Object}, data values to \texttt{Slot}.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=3.3in]{5.Implementation/slot_model.pdf}
  \caption[A generic metamodel for MOF]{A generic metamodel for MOF, based on \cite{mof} and taken from \cite{rose09enhanced}.}
  \label{fig:slot_model}
\end{figure}

Using the metamodel in Figure~\ref{fig:slot_model} in conjunction with MOF, conformance constraints can be expressed, as shown below. A minimal subset of MOF is shown in Figure~\ref{fig:minimal_mof}.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=3.3in]{5.Implementation/mof.pdf}
  \caption[Minimal MOF metamodel]{Minimal MOF metamodel, based on \cite{mof} and taken from \cite{rose09enhanced}.}
  \label{fig:minimal_mof}
\end{figure}

The following constraints between metamodels (e.g. instances of MOF, Figure~\ref{fig:minimal_mof}) and models represented with a generic metamodel (e.g. instances of Figure~\ref{fig:slot_model}) can be used to express conformance:

\begin{enumerate}
	\item Each object's type must be the name of some non-abstract metamodel class.
	\item Each object must specify a slot for each mandatory feature of its type.
	\item Each slot's feature must be the name of a metamodel feature. That metamodel feature must belong to the slot's owning object's type.
	\item Each slot must be multiplicity-compatible with its feature. More specifically, each slot must contain at least as many values as its feature's lower bound, and at most as many values as its feature's upper bound.
  \item Each slot must be type-compatible with its feature.
\end{enumerate}

% TODO illustrate for person (think I do this in the next section, maybe move to here)

The way in which type-compatibility is checked depends on the way in which the modelling framework is implemented. In EMF, for example, model values conform either to types defined in a metamodel, or to types defined in the underlying programming language, Java. EMF provides programmatic access to a metamodel's type system, which can be used to implement type-compatibility checks.

Conformance constraints vary over modelling languages. For example, Ecore, the modelling language of EMF, is similar to but not the same as MOF. Metamodel features defined in Ecore can be marked as transient (not stored to disk) or unchangeable (read-only). Consequently in EMF, conformance constraints are required to restrict the feature value of slots to only non-transient, changeable features.


\subsection{Example}
\label{subsec:mmi_syntax_example}
By binding a model to the generic metamodel presented in Figure~\ref{fig:slot_model} rather than to the underlying programming languages types defined in its metamodel, conformance can be checked using the above constraints. Binding the XMI in Listing~\ref{lst:xmi} to the generic metamodel shown in Figure~\ref{fig:slot_model} produces three instances of \texttt{Ob\-je\-ct}, illustrated as a UML object diagram in Figure~\ref{fig:generic_binding}. For clarity, instances of \texttt{Ob\-je\-ct} are shaded, and instances of \texttt{Sl\-ot} are unshaded. The first \texttt{Ob\-je\-ct} represents the \texttt{Fa\-mi\-ly} model element and has three slots. Two of the slots are used to reference the \texttt{Pe\-rs\-on} model elements via the \texttt{na\-tu\-r\-alCh\-il\-dr\-en} and \texttt{ad\-op\-t\-edCh\-il\-dr\-en} references. When binding to a generic metamodel, models are represented in terms of a set of types that is metamodel-independent (\texttt{Mo\-d\-el}, \texttt{Ob\-je\-ct} and \texttt{Sl\-ot}), and hence binding succeeds for conformant and non-conformant models.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=4in]{5.Implementation/GenericBinding.pdf}
  \caption{Exemplar instantiation of generic metamodel.}
  \label{fig:generic_binding}
\end{figure}

After binding to the generic metamodel, the conformance of a model can be checked against any specific metamodel. To illustrate the value of the generic metamodel, consider again the metamodel evolution in Figure~\ref{fig:x} and the model in Figure~\ref{fig:y}. Conformance checking for the model element representing the \texttt{Fa\-mi\-ly} would now fail because it defines slots for features named  \texttt{na\-tu\-r\-alCh\-il\-dr\-en} and \texttt{ad\-op\-t\-edCh\-il\-dr\-en}, which are no longer defined for the metamodel class \texttt{Fa\-mi\-ly}. Specifically, the model element representing the \texttt{Fa\-mi\-ly} does not satisfy conformance constraint 4 (Section~\ref{subsec:binding}), which states: \emph{each slot's feature must be the name of a metamodel feature. That metamodel feature must belong to the slot's owning object's type}. 

\subsection{Structures built atop the metamodel-independent syntax}
There are many potential uses for the metamodel-independent syntax described in this section. Section~\ref{sec:notation} describes a textual modelling notation integrated with the metamodel-independent syntax to achieve live conformance checking. The migration language presented in Section~\ref{sec:flock} can be used with the metamodel independent syntax to perform partial migration (i.e. to produce models that conform to a generic metamodel rather than their evolved metamodel), but implementation of this work is not complete\footnote{The current version does not support metamodels that contain non-containment references and enumeration types.}.

One of the model migration tools discussed in Section~\ref{sec:analyis_of_languages_used_for_migration}, COPE \cite{herrmannsdoerfer09cope}, uses a metamodel-independent syntax similar to the one presented in this section. The metamodel-independent syntax presented here was developed independently of the metamodel-independent syntax developed for COPE. The two syntaxes were first published in 2008 (\cite{rose08hutn,herrmannsdoerfer08cope}), and are both conceptually similar to the metamodel for UML Object diagrams \cite{uml14}.

In addition to these uses, the metamodel-independent syntax is potentially useful during metamodel installation. As discussed in Section~\ref{subsec:modelling_framework_characteristics}, metamodel developers do not have access to downstream models, and conformance is implicitly enforced by modelling frameworks. Consequently, the conformance of models may be affected by the installation of a new version of a metamodel, and the conformance of models cannot be checked during installation. Typically, installing a new version of a metamodel can result in models that no longer conform to their metamodel and cannot be used with the modelling framework. Moreover, a user discovers conformance problems only when attempting to use a model after installation has completed, and not as part of the installation process.

% TODO - Consider discussing the number of revisions of say, UML (and other metamodels), in Chapter 2. This will allow the reader to get a sense of the scale of the problem.

To enable conformance checking as part of metamodel installation in EMF, the metamodel-independent syntax has been integrated with Concordance in \cite{rose10concordance}. The work was conducted outside of the scope of the thesis, and is now summarised to indicate the usefulness of the metamodel-independent syntax for supporting the automation of co-evolution activities. Concordance provides a mechanism for resolving inter-model references (such as those between models and their metamodels). Without Concordance, determining the the instances of a metamodel is possible only by checking every model in the workspace. Integrating Concordance and the metamodel-independent syntax resulted in a service, which Epsilon (Section~\ref{subsec:epsilon}) executes after the installation of a metamodel to identify the models that are affected by the metamodel changes. All models that conform to the old version of the metamodel are checked for conformance with the new metamodel. As such, conformance checking occurs automatically and immediately after metamodel installation. Conformance problems are detected and reported immediately, rather than when an affected model is next used.

\subsubsection{Summary}
Modelling frameworks implicitly enforce conformance, which presents challenges for managing co-evolution. In particular, detecting and reconciling conformance problems involves managing non-conformant models, which cannot be loaded by modelling frameworks and hence cannot be used with model editors or model management operations. The metamodel-independent syntax proposed in this section enables modelling frameworks to load non-conformant models by binding models to a generic metamodel. The metamodel-independent syntax has been integrated with Concordance \cite{rose10concordance} to facilitate the reporting of conformance problems during metamodel installation, and underpins the implementation of the textual modelling notation presented in Sections~\ref{sec:notation}. The benefits and drawbacks of the metamodel-independent syntax in the context of user-driven co-evolution are explored in Chapter~\ref{Evaluation}. 
