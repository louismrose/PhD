%!TEX root = /Users/louis/Documents/PhD/Deliverables/Thesis/thesis.tex

\section{Research Relating to MDE}
\label{sec:mde_related}

\subsection{Domain-Specific Languages}
For a set of closely-related problems, a specific, tailored approach is likely to provide better results than instantiating a generic approach for each problem \cite{deursen00dslbib}. The set of problems for which the specific approach outperforms the generic approach is termed the problem domain. A \textit{domain-specific programming language} (often called a \textit{domain-specific language} (DSL)) enables solutions in a particular problem domain to be encoded.

Like modelling languages, DSLs describe abstract syntax. Furthermore, a common language can be used to define DSLs (e.g. EBNF \cite{ebnf}), like the use of MOF for defining modelling languages. In addition to abstract syntax, DSLs always define a textual concrete syntax, whereas modelling languages can utilise a graphical concrete syntax (e.g. UML), a textual concrete syntax (e.g. Human-Usable Textual Notation (HUTN) \cite{hutn}) or no concrete syntax. Therefore, DSLs can be thought of as a subset of (domain-specific) modelling languages. As such, it is useful to identify the ways in which DSLs are being used for software development, in addition to the survey of approaches to performing MDE.

Cobol, Fortran and Lisp started life as DSLs for solving problems in the domains of business processing, numeric computation and symbolic processing respectively, and evolved to become general-purpose programming languages \cite{deursen00dslbib}. DSLs are often designed to be very simple, especially at inception; they can grow to become complicated (e.g. SQL). However, a DSL cannot be used to program an entire application. Within their domain, simple DSLs are easy to read, understand and edit \cite{fowler05language}.

A typical approach to constructing a DSL (termed \textit{embedding} a DSL) involves describing the domain using constructs from a general-purpose language (the \textit{host}), such as classes, interfaces and message passing in an object-oriented language \cite{dmitriev04lop}. Examples of embedding a DSL include the frameworks for working with collections that are included in some programming languages (e.g. STL for C++, the Collections API for Java). Some languages are better hosts. For example, Fowler \cite{fowler05language} proposes Ruby as a suitable host due to its ``unintrusive syntax and flexible runtime evaluation.'' Graham \cite{graham93lisp} describes a related style of development in Lisp, where macros are used to translate domain-specific concepts to Lisp abstractions.

However, \cite{dmitriev04lop} reports that embedding a DSL is often unsatisfactory, as the problem domain must be constructed by using the concepts specified in the host, which is a general-purpose language. This leads to a mismatch between domain and programming abstractions, which must be bridged by skilled developers. \cite{dmitriev04lop} suggests that a good DSL should not be bound to programming language abstractions. Developing a translation for programs written in a DSL to programs written in a general-purpose language is one alternative to embedding. Programs written in simple DSLs are often easy to translate to programs in an existing general-purpose language. Approaches to translation include preprocessing; building or generating an interpreter or compiler; or extending an existing compiler or interpreter \cite{dmitriev04lop}.

DSLs have been successfully used as part of application development in many domains, as described in \cite{deursen00dslbib}. They have been used in conjunction with general-purpose languages to build systems rapidly and to improve productivity in the development process (e.g. DSLs for the automation of system deployment and configuration). More recently, some developers are building complete applications by stitching together DSLs, in a style of development called Language-Oriented Programming. 

\subsection{Language-Oriented Programming}
\cite{ward94lop} coins the term Language-Oriented Programming (LOP) to describe a style of development in which a very high-level language is used to encode the problem domain. Simultaneously, a compiler is developed to translate programs written in the high-level language to an existing programming language. Ward describes how this approach to programming can enhance the productivity of development and the understandability of a system. Additionally, Ward mentions the way in which multiple very high-level languages could be layered to separate domains.

The high-level languages that Ward discusses are domain-specific. \cite{fowler05language} notes that combining DSLs to solve a problem is not a new technique. Traditionally, UNIX has encouraged developers to use small (domain-specific) languages (such as awk, make, sed, lex, yac) together to solve problems. Lisp (and, more recently, Ruby) programmers often construct domain-specific languages when developing programs \cite{graham93lisp}. Smalltalk also has a strong tradition of this style of development \cite{fowler05language}.

To fully realise the benefits of LOP, the development effort required to construct DSLs must be minimised. Two approaches seem to be prevalent. The first advocates using a highly dynamic, reflexive and extensible programming language. Clark terms this category of language a \textit{superlanguage} \cite{clark08superlanguages}. The superlanguage permits new DSLs to re-use constructs from existing DSLs, which simplifies development.

A \textit{language workbench} \cite{fowler05language} is an alternative means for simplifying DSL development. Language workbenches provide tools, wizards and DSLs for defining abstract and concrete syntax, for constructing editors and for specifying code generators.

For defining DSLs, the main difference between using a language workbench or a superlanguage is the way in which semantics of language concepts are encoded. In a language workbench, a typical approach is to write a generator for each DSL (e.g. MPS \cite{mps}), whereas a superlanguage often requires that semantics be encoded in the definition of language constructs (e.g. XMF \cite{xmf}).

\cite{clark08superlanguages} acknowledges that a modern development environment for a superlanguage is an important concern. Therefore, the success of both LOP approaches depends, to some extent, upon the quality of their development environment (or workbench). Dependency on language workbenches is a key difference between LOP and MDE for two reasons:

\begin{enumerate}
 \item The emphasis for LOP is in defining (textual) concrete syntaxes. Tools for MDE often provide an editor for manipulating abstract syntax directly, and constructing models using a concrete syntax is optional. Graphical (diagrammatic) concrete syntaxes are also popular when modelling.
 \item MDE tools frequently support many types of model-management operation (such as model-to-model transformation and model merging), while language workbenches concentrate solely on translating DSL programs to code using generators. (Superlanguages do not need to provide any facilities for manipulating the abstract syntax directly).
\end{enumerate}

Some of the key concerns for MDE tools are also important to the success of language workbenches. For example, tools for performing LOP and MDE need to be as usable as those available for traditional development, which often include support for code-completion, automated refactoring and debugging. Presently, these features are often lacking in  tools that support LOP or MDE.

In summary, LOP addresses many of the same issues with traditional development as MDE, but requires a different style of tool. LOP tools focus more on the integration of distinct DSLs, and providing editors and code generators for them; while MDE tools concentrate more on model management operations, such as model-to-model transformation.

Jetbrains MPS:
http://www.jetbrains.com/mps/index.html
http://blogs.jetbrains.com/mps/
http://confluence.jetbrains.net/display/MPS/MPS+User%27s+Guide
http://www.jetbrains.net/devnet/community/mps


\subsection{Grammarware}
\label{subsec:grammarware}
- Relationship between grammars and metamodels (as discussed in ``Toward an Engineering Discipline for Grammarware'', Klint, particularly section 2).