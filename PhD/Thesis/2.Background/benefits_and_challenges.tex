%!TEX root = /Users/louis/Documents/PhD/Deliverables/Thesis/thesis.tex

\section{Benefits of and Current Challenges to MDE}
\label{sec:mde_benefits_and_challenges}
Compared to traditional software engineering approaches and to domain-specific languages and language-oriented programming, MDE has several benefits and weaknesses. This section identifies benefits of and challenges to MDE, synthesised from the literature reviewed in this chapter.

\subsection{Benefits}
\label{subsec:mde_benefits}
Two benefits of MDE are now identified, and used to describe the advantages of the MDE principles and practices discussed in this chapter. 

\paragraph{Tool interoperability} MOF, the standard MDE metamodelling language, facilitates interoperability between tools via model interchange. With Ecore, EMF provides a reference implementation of MOF atop which many contemporary MDE tools are built. Interoperability between modelling tools allows model management to be performed across a range of tools, and developers are not tied to one vendor. Furthermore, models represented in a range of modelling languages can be used together in a single environment. Prior to the formulation of MOF, developers would use different tools for each modelling language. Each tool would likely have different storage formats, complicating the interchange of models between tools.

\paragraph{System evolution} The guidelines set out for MDE in MDA \cite{mda} highlight principles and patterns for modelling to increase the adaptability of software systems by, for example, separating platform-specific and platform-independent detail. When the target platform changes (for example a new technological architecture is required), only part of the system needs to be changed. The platform-independent detail can be re-used wholesale. 

Related to this, MDE facilitates automation of the error-prone or tedious elements of software engineering. For example, code generation can be used to automatically produce so-called ``boilerplate'' code, which is repetitive code that cannot be restructured to remove duplication (typically for technological reasons).

While MDE can be used to reduce the extent to which a system is changed in some circumstances, MDE also introduces additional challenges for managing system evolution \cite{Mens07}. For example, mixing generated and hand-written code typically requires a more elaborate software architecture than would be used for a system composed of only hand-written code. Further examples of the challenges that MDE presents for evolution are discussed in the sequel.

\subsection{Challenges}
\label{subsec:mde_challenges}
Three challenges for MDE are now identified, and used to motivate areas of potential research for improving MDE. The remainder of the thesis focuses on the final challenge, maintainability in the small.

\paragraph{Learnability} MDE involves new terminology, development activities and principles for software engineering. For the novice, producing a simple system with MDE is arguably challenging. For example, \cite{kolovos10eugenia} posits that GMF is difficult for new users to understand, and proposes a simplifying mechanism for GMF. It seems reasonable to assume that the extent to which MDE tools and principles can be learnt will eventually determine the adoption rate of MDE.

\paragraph{Scalability} As discussed in \cite{rose10concordance}, in traditional approaches to software engineering a model is considered of comparable value to any other documentation artefact, such as a word processor document or a spreadsheet. As a result, the convenience of maintaining self-contained model files which can be easily shared outweighs other desirable attributes. \cite{kolovos08scalability} notes that this perception has led to the situation where single-file models of the order of tens (if not hundreds) of megabytes, containing hundreds of thousands of model elements, are the norm for real-world software projects.

MDE languages and tools must scale such that they can be used with large and complex models. \cite{hearnden06incremental,rath08live,tratt08change} explore ways in which the scalability of model management tasks, such as model transformation, can be improved. \cite{kolovos08scalability} prescribes a different approach, suggesting that MDE research should aim for greater modularity in models, which, as a by-product, will result in greater scalability in MDE. Scalability of MDE tools is a key concern for practitioners and, for this reason, \cite{kolovos08scalability} terms scalability the ``holy grail'' of MDE.

\paragraph{Maintainability in the small} Notwithstanding the benefits of MDE for managing the evolution of systems, the introduction of additional development artefacts (such as models and metamodels) and activities (such as model management) presents additional challenges for the way in which developers manage software evolution \cite{Mens07}. For example, in traditional approaches to software engineering, maintainability is achieved by restructuring code, updating documentation and regression testing \cite{feathers04working}. It is not yet clear the extent to which existing maintenance activities can be applied in MDE. (For example, should models be tested and, if so, how?)

As demonstrated in Chapter~\ref{Analysis}, the way in which some MDE tools are structured limits the extent to which some traditional maintenance activities can be performed. Understanding, improving and assessing the way in which evolution is managed in the context of MDE is an open research topic to which this thesis contributes. 

\subsection{Summary}
This section has identified some of the benefits of and challenges for contemporary MDE. The interoperability of tools and modelling languages in MDE allows developers greater flexibility in their choice of tools and facilitates interchange between heterogenous tools and modelling frameworks. MDE is more flexible than other, more formal approaches to software engineering, which can be beneficial for constructing complex systems. The principles and practices of MDE can be used to achieve greater maintainability of systems by, for example, separating platform-independent and platform-specific details.

As MDE tools approach maturity, non-functional requirements, such as learnability, and scalability, become increasingly desirable for practitioners. MDE tools must also be able to support developers in managing changing software. This section has demonstrated some of the weakness of contemporary MDE, particularly in the areas of learnability, scalability and maintainability.