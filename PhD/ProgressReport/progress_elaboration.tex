%!TEX root = /Users/louis/Documents/PhD/Deliverables/ProgressReport/pr.tex
\subsection{Elaboration of Research Aims}
\label{sub:elaboration}
The aim of my research is to develop structures and processes for evolutionary changes in the context of model-driven engineering. Since submitting my qualifying dissertation, I have identified two categories of evolutionary change (for which structures and processes can be developed) by reviewing literature relating to evolution in MDE. Both are discussed below.

\subsubsection{Model and Metamodel Co-Evolution} % (fold)
\label{ssub:model_and_metamodel_co_evolution}
A metamodel is a model that describes a collection of concepts that are used for specifying models in a particular domain. A model and metamodel are \emph{consistent} when the metamodel describes every concept used in the model definition. Consistency can be described by a set of constraints between models and metamodels (i.e. when all constraints are satisfied, a model and a metamodel are consistent). The Eclipse Modelling Framework\footnote{The Eclipse Modelling Framework (EMF) \cite{emf} provides tools for developing, managing and instantiating metamodels.} specifies many constraints for checking model and metamodel consistency. One such constraint states that every object in the model has a corresponding non-abstract class in the metamodel.

A metamodel can evolve (be adapted by a developer), which can cause inconsistency. For example, suppose a concept is removed from a metamodel. Any models that use the removed concept are now inconsistent with the metamodel. Co-evolution is the process of evolving both metamodel and model such that they remain consistent. In existing approaches for managing model and metamodel co-evolution (such as \cite{herrmannsdoerfer08cope,cicchetti08automating}), metamodel evolution occurs first, possibly causing models to become inconsistent. Any inconsistent models are then evolved to re-establish consistency.


\subsubsection{Model Synchronisation} % (fold)
\label{ssub:model_synchronisation}
Often, MDE is used to generate code from a model. The MDA guidelines suggest beginning by defining a platform-independent model, and using at least one transformation to produce platform-specific model(s). Code is then generated from the final platform-specific model. When one model evolves, the changes need to be propagated to other models. This activity is termed \textit{model synchronisation}.

Existing model synchronisation literature focuses mostly on enabling \textit{incremental transformation}, a style of model transformation that incrementally updates the target model. For large models, transformation execution time has been shown to be significantly reduced by using incremental transformation \cite{hearnden06incremental}. However, \cite{kolovos08scalability} suggests that reducing the size of models (using modularisation) is likely to yield better results than attempting to develop techniques for scaling up model management tasks (such as model transformation). Consequently, I believe that the focus of existing model synchronisation literature is misplaced; model synchronisation research should seek to improve maintainability rather than scalability.  %TODO : read Dimitrios's paper and make this argument strong; "likely to yield better results" is inspecific and weak

Although much of the model synchronisation literature concentrates on incremental transformation, there are other closely-related areas of research, which are more relevant to my work. For instance, \cite{jouault05loosely,drivalos08loosely} describe models of traceability, which could be used to perform \textit{impact analysis} (highlighting the consequences of performing an evolutionary change). Eclipse's Java Development Tools project successfully employs impact analysis for illustrating the effects of Java refactorings \cite{fuhrer07refactoring}. I am unaware of any existing work that explores implementing impact analysis for MDE tools.