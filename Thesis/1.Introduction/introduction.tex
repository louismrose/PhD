%!TEX root = /Users/louis/Documents/PhD/Deliverables/Thesis/thesis.tex

\chapter{Introduction}
\label{Introduction}
Today's software engineers build distributed and interoperating systems with sophisticated graphical interfaces rather than the insular, monolithic, and command-line driven mainframe applications built by their predecessors. For \cc example, the NatWest and Royal Bank of Scotland banking systems were successfully unified in 2003, which involved processing 14 million customer records, 13 million account records and 22 million direct debits in a single weekend \cite[pg26]{rae04challenges}. Distributed and interoperable systems are key requirements in the National Programme for IT\footnote{\url{http://www.connectingforhealth.nhs.uk/about/benefits/statement0607.pdf}}, which seeks to modernise the United Kingdom's National Health Service with computerised systems for managing the nation's patient records. In the United States of America, the goals of the Department of Defense depend on increasingly complex systems, which encompass ``thousands of platforms, sensors, decision nodes, weapons, and war-fighters connected through heterogeneous wired and wireless networks'' \cite{northrop06ulss}.

Some of the software demanded by users and developers today is so complicated that its construction is not possible, even using state-of-the-art software engineering techniques \cite{selic03pragmatics}. For \cc example, a large supermarket chain recently planned to develop software for managing a new loyalty card scheme. However, implementing the system would have involved devising algorithms for efficiently searching 4 terabytes of customer data, and it was deemed impossible to implement despite its obvious commercial advantages \cite[pg15]{rae04challenges}. Demand, however, does not appear to exceed capability in all areas of computer science.

%\cite{pool97society} observes that a similar situation occurred when steam and electrical power were introduced during the Industrial Revolution. 

Hardware development, for example, seems to advance more quickly than software development. Each year, faster personal computers with larger disk drives become available, while operating systems, office software and development environments seem to improve more gradually. Radical \cc advances in software development appear to occur only by raising the level of abstraction at which software is specified \cite{brooks86nosilverbullet,selic03pragmatics,kleppe03mda}. Improvements \cc to the training and education of software engineers have also been suggested as key for the construction of increasingly complex software systems \cite{rae04challenges}.



%  

% \cite{brooks86nosilverbullet} observes that engineering increasingly complicated systems with traditional development approaches presents many challenges, including:
% 
% \begin{enumerate}
%  \item \textit{Increasing size of development teams}: large teams may experience communication difficulties, detracting from productivity.
%  \item \textit{Difficulties providing system overviews}: incomplete system knowledge can impede maintenance activities.
%  \item \textit{Poor understandability}: new developers suffer a complex learning curve.
%  \item \textit{Resistance to change}: development reacts slowly when requirements change, new underlying technologies are to be adopted, and unintended behaviour must be corrected.
% \end{enumerate}
% 
% 
% 
% Improvements to development processes have also facilitated greater abstraction. For example, developers are increasingly employing models of systems to aid design and implementation. During the 1990s, methods that prescribed modelling to aid software development were popular. A common modelling language, the Unified Modelling Language (UML) \cite{uml212}, was standardised by combining the modelling languages from three methods \cite{}. By communicating designs and abstracting away from unimportant details, software engineers are using models to address the first three of Brooks's challenges. However, modelling is effective only when the models are an accurate representation of the computer system.

% During a system's lifecycle, design documents are often neglected and become out-of-date. Without a well-defined connection to the system's implementation, models are effectively design documents that might be neglected and can become inaccurate representations of the system \cite{frankel02mda,kleppe03mda}. For models to be used as effective means of communication and education, they must be accurate and, therefore, must be maintained and updated in response to change. Maintaining two unconnected representations of a system (models and implementation) obviously detracts from the productivity of the development team. Instead, an approach to software development that integrates modelling and coding can be used to address this productivity problem, as well as the first three of Brooks's challenges.


\input{1.Introduction/topics}
\input{1.Introduction/problems}
\input{1.Introduction/hypothesis_and_method}
\input{1.Introduction/results}
\input{1.Introduction/structure}

