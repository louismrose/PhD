%!TEX root = ../thesis.tex

\section{Research Relating to MDE}
\label{sec:mde_related}
MDE is closely related to several other fields of software engineering. This section discusses two of those fields, Domain-Specific Languages (DSLs) and Language-Oriented Programming (LOP). A further related area, Grammarware, is discussed in the context of software evolution in Section~\ref{subsec:grammar_evolution}. DSLs and LOP are closely related to the research central to this thesis. Other areas relating to MDE but less relevant to this thesis, such as formal methods, are not considered here.

\subsection{Domain-Specific Languages}
\label{subsec:dsls}
For a set of related problems, a specific, tailored approach is likely to provide better results than instantiating a generic approach for each problem \cite{deursen00dslbib}. The set of problems for which the specific approach outperforms the generic approach is termed the \emph{domain}. A \emph{domain-specific programming language} (often called a \emph{domain-specific language} or \emph{DSL}) enables the encoding of solutions for a particular domain.

Like modelling languages, DSLs describe abstract syntax. Furthermore, a common language can be used to define DSLs (e.g. EBNF \cite{ebnf}), like the use of MOF for defining modelling languages. In addition to abstract syntax, DSLs typically define a textual concrete syntax but, like modelling languages, can utilise a graphical concrete syntax.

Cobol, Fortran and Lisp first existed as DSLs for solving problems in the domains of business processing, numeric computation and symbolic processing respectively, and evolved to become general-purpose programming languages \cite{deursen00dslbib}. SQL, on the other hand, is an example of a DSL that, despite undergoing much change, has not grown into a general-purpose language. Unlike a general-purpose language, a single DSL cannot be used to program an entire application. DSLs are often small languages at inception, but can grow to become complicated (such as SQL). Within their domain, DSLs should be easy to read, understand and edit \cite{fowler10dsls}.

There are two ways in which DSLs are typically implemented. An \emph{internal} DSL uses constructs from a general-purpose language (the \emph{host}) to describe the domain \cite{fowler10dsls}. Examples of internal DSLs include the libraries of abstract data types that are part of many programming languages (e.g. STL for C++, the Collections API for Java). Some languages are better than others for hosting internal DSLs. For \cc example, Ruby has been proposed as a suitable host for DSLs due to its unintrusive syntax and flexible runtime evaluation \cite[ch. 4]{fowler10dsls}. In Lisp, internal DSLs can be implemented by using macros to translate domain-specific concepts to Lisp abstractions \cite{graham93lisp}.

When the gap between domain and programming concepts is large, constructing an internal DSL can require a lot of programming effort. Consequently, \cc \emph{translating} DSL programs into code written in a general-purpose language has been recommended \cite{parr07antlr}. The \cc term \emph{external} is sometimes used for this style of DSL implementation \cite{fowler10dsls}. Programs written in simple DSLs are often easy to translate to programs in an existing general-purpose language \cite{parr07antlr}. Approaches to translation include preprocessing; building or generating an interpreter or compiler; or extending an existing compiler or interpreter \cite{fowler10dsls}.

The construction of an external DSL can be achieved using many of the principles, practices and tools used in MDE. Parsers can be generated using text-to-model transformation; syntactic constraints can be specified with model validation; and translation can be specified using model-to-model and model-to-text transformation. MDE tools are used to implement two external DSLs in Chapter~\ref{Implementation}.

Internal \cc and external DSLs have been successfully used as part of application development in many domains \cite{deursen00dslbib}. They have been used in conjunction with general-purpose languages to build systems rapidly and to improve productivity in the development process (such as automation of system deployment and configuration). More recently, some developers are building complete applications by combining DSLs, in a style of development called Language-Oriented Programming. 

\subsection{Language-Oriented Programming}
DSLs \cc are central to LOP, a style of software development \cite{ward94lop}. Firstly, a very high-level language to encode problem domains is developed. Simultaneously, a compiler is developed to translate programs written in the high-level language to an existing programming language. Ward describes how this approach to programming can enhance the productivity of development and the understandability of a system. Additionally, Ward mentions the way in which multiple very high-level languages could be layered to separate domains.

Combining \cc DSLs to solve a problem is not a new technique \cite{fowler10dsls}. Traditionally, UNIX has encouraged developers to combine programs written in small (domain-specific) languages (such as awk, make, sed, lex and yac) to solve problems. Lisp, Smalltalk and Ruby programmers often construct domain-specific languages when developing programs \cite{graham93lisp}.

To fully realise the benefits of LOP, the development effort required to construct DSLs must be minimised. Two approaches for constructing DSLs seem to be prevalent for LOP. The first advocates using a highly dynamic, reflexive and extensible programming language to specify DSLs. This category of language has been termed a \emph{superlanguage} \cite{clark08superlanguages}. The superlanguage permits new DSLs to re-use constructs from existing DSLs, which simplifies development.

A \textit{language workbench} \cite[ch. 9]{fowler10dsls} is an alternative means for simplifying DSL development. Language workbenches provide tools, wizards and DSLs for defining abstract and concrete syntax, for constructing editors and for specifying code generators.

For defining DSLs, the main difference between using a language workbench or a superlanguage is the way in which semantics of language concepts are encoded. In a language workbench, a typical approach is to write a generator for each DSL \cite{fowler10dsls}, whereas a superlanguage often requires that semantics be encoded in the definition of language constructs \cite{clark08superlanguages}.

Like MDE, LOP requires mature and powerful tools and languages to be applicable in the large, and to complex systems. Unlike MDE, LOP tools typically combine concrete and abstract syntax. The emphasis for LOP is in defining a single, textual concrete syntax for a language. MDE tools might provide more than one concrete syntax for a single modelling language. For example, two distinct concrete syntaxes are used for the tree-based and graphical editors of the simple state-machine language shown in Figures~\ref{fig:emf_model_editor} and~\ref{fig:gmf_model_editor}.

Some of the key concerns for MDE are also important to the success of LOP. For example, tools for performing LOP and MDE need to be as usable as those available for traditional development, which often include support for code-completion, automated refactoring and debugging. Presently, these features are often lacking in tools that support LOP or MDE.

In summary, LOP addresses many of the same issues with traditional development as MDE, but requires a different style of tool. LOP focuses more on the integration of distinct DSLs, and providing editors and code generators for them. Compared to LOP, MDE typically provides more separation between concrete and abstract syntax, and concentrates more on model management.

\subsection{Summary}
This section has described two areas of research related to MDE, domain-specific languages (DSLs) and language-oriented programming (LOP). DSLs facilitate the encoding of solutions for a particular problem domain. For solving problems in their domain, DSLs can be easier to read, use and edit than general-purpose programming languages \cite{deursen00dslbib,fowler10dsls}. During MDE, one or more DSLs may be used to model the domain, and the tools and techniques for implementing DSLs can be used for MDE.

LOP is an approach to software development that seeks to specify complete systems using a combination of DSLs. Contemporary LOP seeks to minimise the effort required to specify and use DSLs. Like MDE, LOP requires mature and powerful tools, but, unlike MDE, LOP does not separate concrete and abstract syntax, and does not focus on model management, which is a key development activity in MDE.
